== Setup {etm}
This section explains in detail the steps to download, configure and run an {etm} installation. Because {etm} is a pure Java application it should be able to run on any machine with a proper Java runtime installed. At a minimum a link:http://www.oracle.com/technetwork/java/javase/downloads/index.html[Java 8] runtime should be available. It is recommended to install JDK from Oracle's site, but {etm} might run with other JDK suppliers as well.

For the storage of the events {etm} relies on an link:http://www.elastic.co/downloads[Elasticsearch {elasticsearch-major-version}] or compatible cluster. Both the Java runtime, and Elasticsearch cluster are not part of {etm} and need to be installed, configured and managed separately.

=== System requirements
{etm} works best on machines that are equipped with 8 to 64 GiB of RAM. More than 64 GiB makes the Java garbage collections run so long that it has an overall negative impact on the performance. In most situations 8 GiB is more than sufficient, but when you need to process a lot of big events you might need some more memory.

If your system is running on spinning disk you might consider upgrade to SSD or even NVME disks. This is in particular important for your Elasticsearch nodes! Elasticsearch will store and retrieve all the event data, so make sure your disks at these nodes are as fast as possible. They will be most likely the bottleneck of your {etm} cluster setup.

Processing events is the most CPU intensive task in {etm}. Because events are processed in parallel {etm} takes a huge benefit from multi-core CPU's. If you have to choose between a faster CPU or a multi-core CPU always go for the multi-core CPU. 

When you are planning to create a multi node cluster, make sure the nodes are as close to each other as possible. Network latency can have a negative impact on the processing performance. Optical network interfaces are the preferred way to go, but if they are not available to you make sure your servers are equipped with at least Gigabit network interfaces. 

=== Installation with .tgz
The .tgz archive for {etm} can be downloaded and installed as follow:

[source,bash,subs=attributes+]
----
wget https://www.jecstar.com/downloads/etm/etm-{project-version}.tgz
wget https://www.jecstar.com/downloads/etm/etm-{project-version}.tgz.sha512
cat etm-{project-version}.tgz.sha512 | sha512sum -c ## <1>
tar -xvf etm-{project-version}.tgz
cd etm-{project-version}/bin
./etm ## <2>
----
<1> Checks the sha512 hash of the downloaded file. If not ok, this command will fail.
<2> This command does not actually start {etm} but shows the options that are available with the etm script.

=== Installation with .zip
The .zip archive for {etm} can be downloaded and installed as follow:

[source,bash,subs=attributes+]
----
wget https://www.jecstar.com/downloads/etm/etm-{project-version}.zip
wget https://www.jecstar.com/downloads/etm/etm-{project-version}.zip.sha512
cat etm-{project-version}.zip.sha512 | sha512sum -c ## <1>
unzip etm-{project-version}.zip
cd etm-{project-version}/bin
./etm ## <2>
----
<1> Checks the sha512 hash of the downloaded file. If not ok, this command will fail.
<2> This command does not actually start {etm} but shows the options that are available with the etm script.

=== Installation on Windows
Although {etm} best performs on linux like systems it can be run under windows as well. You can download {etm} from https://www.jecstar.com/downloads/etm/etm-{project-version}.zip and unzip it with your favorite archiving tool. In the directory <UNZIP_LOCATION>\etm-{project-version}\bin you will find a file named ''etm.bat''. By executing that batch file {etm} will start.

=== Installation with Docker
{etm} is also available as a Docker image. This image is based on the openjdk:8-jdk-alpine image. To retrieve the image run the following command:

[source,bash,subs=attributes+]
----
docker pull docker.jecstar.com/etm:{project-version}
----

To run the Docker image {etm} needs to know where to find Elasticsearch. The most simple way of doing this is to use an environment variable:

[source,bash,subs=attributes+]
----
docker run -p 8080:8080 -e "elasticsearch_connectAddresses=<my-elasticsearch-host>:<my-elasticsearch-port>" -e "elasticsearch_clusterName=elasticsearch" docker.jecstar.com/etm:{project-version}
----

Most of the properties mentioned in the <<Node configuration>> chapter can be passed as environment variables to the Docker container. Properties not mentioned in the <<General configuration in etm.yml>> but is a separate section of the configuration should be prefixed by their section names. For example, the properties ''elasticsearch.clusterName'' in the configuration file should be passed as environment variable ''elasticsearch_clusterName''. In short, the 'dot' in the configuration file should be replaced with an 'underscore' in the environment variable name.

Another option of configuring the Docker image is by mounting a custom configuration file from from host system to the location the image is expecting the configuration file. This can be done by adding

[source,bash,subs=attributes+]
----
-v full_path_to/custom_etm.yml:/usr/share/etm/config/etm.yml
----

to the Docker run command. Also if you need an <<Integration with IBM MQ and/or IBM Integration Bus>> you need to mount the directory that contains the proprietary IIB and/or MQ jar files to the image:

[source,bash,subs=attributes+]
----
-v full_path_to/proprietary_jar_files:/usr/share/etm/lib/ext
----

IMPORTANT: The container runs {etm} as user etm using uid:gid 1000:1000. Bind mounted host directories and files, such as custom_etm.yml above, need to be accessible by this user. 

=== Installation with Kubernetes

Both {etm} and Elasticsearch are capable of running on Kubernetes. Templates of Kubernetes configuration files can be found at the link:https://github.com/jecstarinnovations/etm/tree/v{project-version}/etm-kubernetes/src/main/kubernetes[Jecstar Github Repository] of {etm}.

These templates give you a good starting point with great flexibility on setting up your cluster. To create an {etm} cluster with 3 Elasticsearch master nodes, 2 Elasticsearch data nodes, 2 Elasticsearch client nodes and 2 {etm} nodes run the following commands on a Google Cloud Platform connected Kubernetes cluster:

[source,bash,subs=attributes+]
----
kubectl create -f storage.yaml
kubectl create -f elasticearch-master-svc.yml
kubectl create -f elasticearch-client-svc.yml
kubectl create -f etm-svc.yml
kubectl create -f elasticearch-master.yml
kubectl create -f elasticearch-data.yml
kubectl create -f elasticearch-client.yml
kubectl create -f etm.yml
----

Of course this 9 node cluster created with the templates might be overkill for your situation, but nothing should stop you from creating a single node Elasticsearch cluster with the use of these templates.

=== Integration with IBM MQ and/or IBM Integration Bus
{etm} is capable of providing deep integration with IBM MQ and or IBM Integration Bus. To make use of any of these integrations the classpath of {etm} needs to be extended. Due to the MQ license Jecstar is not allowed to provide this specific library with {etm}. 

To make use of the IBM MQ integration you need to copy a file named ''com.ibm.mq.allclient.jar'' from your MQ installation to the <INSTALL_DIR>/lib/ext directory. This integration makes it possible to process events from any IBM MQ Destination. For further configuration see the <<IBM MQ section in etm.yml>>.

The IBM Integration Bus integration makes it possible to manage the emission of link:http://www.ibm.com/support/knowledgecenter/SSMKHH_9.0.0/com.ibm.etools.mft.doc/ac60386_.htm[IIB Monitoring Events] from within {etm}.
Depending on your IIB version you need to copy some files to the <INSTALL_DIR>/lib/ext directory of every {etm} node running. Consult the table below to determine which files are necessary for your setup.

.Dependencies based on IIB version
[options="header"]
|=======================
|Filename|IIB 9|IIB 10
|configmanagerproxy.jar|X|
|ibmjsseprovider2.jar|X|X
|integrationapi.jar||X
|jetty-io.jar||X
|jetty-util.jar||X
|websocket-api.jar||X
|websocket-client.jar||X
|websocket-common.jar||X
|=======================

=== Integration with JMS
{etm} is able to process messages from any JMS 2.x compatible message provider. To connect to the desired messaging system you have to add the JMS client jar files of the messaging system to the <INSTALL_DIR>/lib/ext directory of the {etm} installation.

For configuring the connections and destinations that should be read see the <<JMS section in etm.yml>> chapter.

=== Node configuration
Each {etm} Node has its own configuration file. The file can be found at <INSTALL_DIR>/config/etm.yml. When playing around with {etm} the defaults will be sufficient, but when you configure a production instance you probably need to tune some configuration options. The configuration file is split into 5 main sections: general, elasticsearch, http, ibm mq and logging.

Indentation in the etm.yml configuration file is necessary to create nested properties. See the following example for an explanation on how to create lists an key-value mappings.

[source,yaml]
----
property1: value1 <1>
object1: <2>
  sub-property1: value2 <3>
list1:
- listproperty1: value3 <4>
  listproperty2: value4
- listproperty1: value5    
  listproperty2: value4
map1:
  key1: value1 <5>
  key2: value2  
----
<1> This is just a general property with the name ''property1'' and a value of ''value1''. 
<2> A new object with the name ''object1'' is created. An object itself has no direct value, but has (sub)properties with an indentation of 2 spaces.
<3> The property ''sub-poroperty1'' is added to the object ''object1''
<4> A new list is created. A list is actually an object as well because it has no direct value bus has (sub)properties with an indentation of 2 spaces. In this case the list doesn't contain single values but objects. Each object starts with a ''-''.
<5> A new map is created. Just like the list, a map is actually an object. In this case the map contains of simple key/value string pairs.

A detailed specification of the yaml syntax can be found on the link:http://yaml.org/[yaml website].

IMPORTANT: When storing passwords in the etm.yml file, make sure the file is only readable by the {etm} administrators.

==== General configuration in etm.yml
General configuration options have no indentation in the etm.yml file. The following options are available:

.General configuration options
[options="header"]
|=======================
|Name|Default value|Description
|bindingAddress|0.0.0.0|The interface address to bind {etm} to.
|clusterName|Enterprise Telemetry Monitor|The name of the {etm} cluster. When running multiple {etm} clusters it is recommended to give them a separate name.
|instanceName|Node_1|The name of the Node. When running multiple nodes in a cluster, it is recommended to give them a separate name.
|elasticsearch||The elasticsearch configuration. See <<Elasticsearch section in etm.yml>> to view the nested options.
|http||The http configuration. See <<Http section in etm.yml>> to view the nested options.
|ibmMq||The IBM MQ configuration. See <<IBM MQ section in etm.yml>> to view the nested options.
|jms||The JMS configuration. See <<JMS section in etm.yml>> to view the nested options.
|kafka||The Kafka configuration. See <<Kafka section in etm.yml>> to view the nested options.
|signaler||The signaler configuration. See <<Signaler section in etm.yml>> to view the nested options.
|logging||The logging configuration. See <<Logging section in etm.yml>> to view the nested options.
|======================= 

All other configuration sections are identified with the name of the section without indentation. Configuration options in that section have an indentation of 2 spaces.

==== Elasticsearch section in etm.yml
The ''elasticsearch'' section contains all options that are necessary to connect to an Elasticsearch cluster:

.Elasticsearch configuration options
[options="header"]
|=======================
|Name|Default value|Description
|clusterName|elasticsearch|The name of the Elasticsearch cluster to connect to.
|connectAddresses|127.0.0.1:9200|A list of Elasticsearch nodes to connect to. When high availability is a demand of your production environment you should provide at least 2 addresses. The servers must be added in the format "<servername_or_ip>:<port>".
|waitForConnectionOnStartup|false|Wait for any of the connections supplied in the ''connectAddresses'' to be established before fully starting {etm}. This option is usefull when {etm} is started before any of the Elasticsearch nodes is started.
|username||The username used to connect to a secured Elasticsearch cluster.
|password||The password used to connect to a secured Elasticsearch cluster.
|sslTrustStoreLocation||A full path to the jks truststore. Enable this option when you want to make use of a ssl connection to Elasticsearch.
|sslTrustStorePassword||The password of the jks truststore.
|=======================

==== Http section in etm.yml
The ''http'' section contains all options that are necessary to start the gui and REST processor:

.Http configuration options
[options="header"]
|=======================
|Name|Default value|Description
|httpPort|8080|The port to bind the http listener to. To disable the http listener set the value to zero or lower.
|httpsPort|8443|The port to bind the secure https listener to. The listener will not start unless the sslKeystore is properly configured.
|contextRoot|/|The context root under which the gui and REST processor will be available.
|ioThreads|2|The number of IO threads. IO threads handle all non-blocking calls to the web server. One thread per cpu core should be more than sufficient.
|workerThreads|16|The number of worker threads to handle all blocking calls to the web server. Around 10 threads per cpu cure should be a good starting point for servers under a high load.
|guiEnabled|true|Should the GUI be enabled? Set this value to false if you don't want users to use the gui on this node. The gui is bound to the ''/gui'' context on your server and can be accessed by browsing to \http://<bindingAddress>:<httpPort>/gui/
|guiMaxConcurrentRequests|50|The maximum number of request that can be processed in parallel at any given moment by the GUI. If the number exceeds the maximum, the requests will be queued.
|guiMaxQueuedRequests|50|The maximum number of requests that can be queued by the GUI. If a request needs to be queued and the maximum number of queued requests exceeds this maximum the request will be rejected.
|restProcessorEnabled|true|Should the REST processor be enabled? Set this value to false if you don't want this node to act as a processor that can process events with a REST api. The REST api is bound to the ''/rest/processor/'' context and can be access from \http://<bindingAddress>:<httpPort>/rest/processor/
|restProcessorMaxConcurrentRequests|50|The maximum number of request that can be processed in parallel at any given moment by the REST processor. If the number exceeds the maximum, the requests will be queued.
|restProcessorMaxQueuedRequests|50|The maximum number of requests that can be queued by the REST processor. If a request needs to be queued and the maximum number of queued requests exceeds this maximum the request will be rejected.
|sslProtocol|TLSv1.2|The ssl protocol that needs to be used on the secure https listener. The allowed values are depending on your Java installation, but unless you have specific demands the default will be sufficient secure.
|sslKeystoreLocation||The location of you ssl keystore. The keystore contains your public/private key pair to identify your server.
|sslKeystorePassword||The password of the ssl keystore.
|sslKeystoreType|PKCS12|The ssl keystore type.
|sslTruststoreLocation||The location of you ssl truststore. The trust store contains certificates of machines that are allowed to connect to this Node. When not provided, everybody is allowed to access this Node although a a username and password are still necessary to login.
|sslTruststorePassword||The password of the ssl truststore.
|sslTruststoreType|JSK|The ssl truststore type.
|secureCookies|false|Should the secure flag be set on the session cookies? Set this value to true when your {etm} instance is accessed via https.
|=======================

==== IBM MQ section in etm.yml
The ''ibmMq'' section contains all options that are necessary to process {etm} events from a IBM MQ queue or topic. Make sure to add the MQ libraries to the classpath of the Node. See the <<Integration with IBM MQ and/or IBM Integration Bus>> section.

.IBM MQ configuration options
[options="header"]
|=======================
|Name|Default value|Description
|enabled|false|Should the IBM MQ processor be enabled? Set this value to true to process events from defined IBM MQ queue's and/or topics.
|queueManagers||A list of QueueManagers to connect to. See <<ibmmq-queuemanager-options>> to view the nested options.
|=======================

[[ibmmq-queuemanager-options]]
.QueueManager options
[options="header"]
|=======================
|Name|Default value|Description
|name|QMGR|The name of the QueueManager.
|host|127.0.0.1|The hostname or ip-address the QueueManager is running on.
|port|1414|The port the QueueManager is listening on.
|channel||The channel to use to setup the connection to the QueueManager.
|userId||The user id used to setup the connection to the QueueManager.
|password||The password used to setup the connection to the QueueManager.
|sslCipherSuite||The ssl cipher suite to use.
|sslProtocol|TLSv1.2|The ssl protocol that needs to be used to connect to the QueueManager. The allowed values are depending on your Java installation, but unless you have specific demands the default will be sufficient secure.
|sslKeystoreLocation||The location of you ssl keystore. The keystore contains your public/private key pair to identify your Node.
|sslKeystorePassword||The password of the ssl keystore.
|sslKeystoreType|PKCS12|The ssl keystore type.
|sslTruststoreLocation||The location of you ssl truststore. The trust store contains certificates of Queuemanager machines that this Node is allowed to connect to. When not provided, all Queuemanager machines are trusted.
|sslTruststorePassword||The password of the ssl truststore.
|sslTruststoreType|JSK|The ssl truststore type.
|destinations||A list of destinations to listen on. See <<ibmmq-destination-options>> to view the nested options.
|=======================

[[ibmmq-destination-options]]
.Destination options
[options="header"]
|=======================
|Name|Default value|Description
|name||The name of the Queue or Topic to connect to.
|type|queue|The destination type. Can be one of ''queue'' or ''topic''.
|defaultImportProfile||The default <<Import profiles,import profile>> to use on this destination if no import profile is provided within the processing events.
|minNrOfListeners|1|The minimum number of listeners to connect to the destination. Not that auto scaling to maxNrOfListeners only works on local queues.
|maxNrOfListeners|5|The maximum number of listeners to connect to the destination. Not that auto scaling to maxNrOfListeners only works on local queues.
|channel||The channel to use to setup the connection to the QueueManager.
|messagesType|auto|Can be one of ''auto'' which auto detect the message type but is the slowest, ''iibevent'' which is capable of handling http://www.ibm.com/support/knowledgecenter/SSMKHH_9.0.0/com.ibm.etools.mft.doc/ac60386_.htm[IIB Monitoring Events],  ''etmevent'' which is capable of handling events in the {etm} json format or ''clone'' which assumes the message read is a clone of the original message. See the section <<Event layout>> for a description of the {etm} json format.
|maxMessageSize|4194304|The maximum message size in bytes that can be read. Depending on the get options the message will be ignored or truncated.
|commitSize|500|The maximum number of messages processed before a MQCMIT is executed.
|commitInterval|10000|The maximum number of milliseconds the processor can read messages without executing a MQCMIT.
|destinationGetOptions|MQGMO_WAIT + MQGMO_SYNCPOINT + MQGMO_ACCEPT_TRUNCATED_MSG + MQGMO_FAIL_IF_QUIESCING + MQGMO_LOGICAL_ORDER + MQGMO_COMPLETE_MSG + MQGMO_ALL_SEGMENTS_AVAILABLE|The MQ Get options.
|destinationOpenOptions|MQOO_INQUIRE + MQOO_FAIL_IF_QUIESCING + MQOO_INPUT_SHARED|The MQ Open options.
|=======================

==== JMS section in etm.yml
The ''jms'' section contains all options that are necessary to process {etm} events from a JMS queue or topic. Make sure to add the required JMS libraries to the classpath of the Node. See the <<Integration with JMS>> section.

.JMS configuration options
[options="header"]
|=======================
|Name|Default value|Description
|enabled|false|Should the JMS processor be enabled? Set this value to true to process events from defined JMS queue's.
|connectionFactories||A list of connection factories to connect to. See <<connection-factory-options,JMS Connection Factory instantiation>> for the nested options.
|=======================

[[connection-factory-options]]
{etm} supports 2 types of JMS Connection Factory instantiation. Each type has its own tag in the yaml configuration file.

When the Connection Factory must be looked up into a JNDI registry the tag ''!jndiConnectionFactory'' should be used. The JNDI connection factory lookup supports the following options:

.JNDI Connection factory options
[options="header"]
|=======================
|Name|Default value|Description
|initialContextFactory||The full classname of the Initial Context Factory.
|providerURL||The url used to connect to the Intial Context Factory.
|jndiName||The name of the Connection Factory in the JNDI.
|parameters||A map with parameters that will be used to connect to the Iitial Context Factory.
|destinations||A list of destinations to listen on. See <<jms-destination-options>> to view the nested options.
|=======================

When the Connection Factory does not resides in a JNDI registry but should be instantiated directly the tag ''!nativeConnectionFactory'' should be used. The native connection factory instantiation supports the following options:

.Native Connection factory options
[options="header"]
|=======================
|Name|Default value|Description
|className||The full classname of the Connection Factory.
|constructorParameters||A list with parameters that will be passes to the constructor while instantiating the class.
|parameters||A map with parameters that will be set on the Connection Factory instance.
|destinations||A list of destinations to listen on. See <<jms-destination-options>> to view the nested options.
|=======================

[[jms-destination-options]]
.Destination options
[options="header"]
|=======================
|Name|Default value|Description
|name||The name of the Queue or Topic to connect to.
|type|queue|The destination type. ''queue'' is the only supported option.
|minNrOfListeners|1|The minimum number of listeners to connect to the destination.
|maxNrOfListeners|5|The maximum number of listeners to connect to the destination.
|messagesType|auto|Can be one of ''auto'' which auto detect the message type but is the slowest, ''etmevent'' which is capable of handling events in the {etm} json format or ''clone'' which assumes the message read is a clone of the original message. See the section <<Event layout>> for a description of the {etm} json format.
|defaultImportProfile||The default <<Import profiles,import profile>> to use on this destination if no import profile is provided within the processing events.
|=======================

==== Kafka section in etm.yml
The ''kafka'' section contains all options that are necessary to process {etm} events from a link:https://kafka.apache.org/[Kafka] topic.

.Kafka configuration options
[options="header"]
|=======================
|Name|Default value|Description
|enabled|false|Should the Kafka processor be enabled? Set this value to true to process events from defined Kafka topics.
|topics||A list of topics to read from. See <<kafka-topic-options>> to view the nested options.
|=======================

[[kafka-topic-options]]
.Topic options
[options="header"]
|=======================
|Name|Default value|Description
|name||The name of the topic to connect to.
|bootstrapServers||A list of bootstrap servers to connect to. The servers must be added in the format "<servername_or_ip>:<port>".
|nrOfListeners|1|The number of listeners to connect to read from the topic. This number should never be higher that the number of partitions in your topic.
|groupId|Enterprise Telemetry Monitor|The name of the group id to connect to the topic. All {etm} Nodes should have the same group id.
|startFrom||Set to ''beginning'' to start processing from the begin of the topic instead of the saved offset.
|defaultImportProfile||The default <<Import profiles,import profile>> to use on this destination if no import profile is provided within the processing events.
|maxPollRecords||The maximum number of records to retrieve in a single call to the topic.
|maxPollInterval||The maximum number of milliseconds allowed between two retrieval calls to the topic. If the processing took longer the Node will be considered failed and the topic will be rebalanced.
|sessionTimeout||The timeout used to detect consumer failures. If this Node will not send a heartbeat within this interval the Node will be considered failed and the topic will be rebalanced.
|heartbeatInterval||The expected time between heartbeats. This value should always be lower as the sessionTimeout value.
|sslCipherSuite||The ssl cipher suite to use.
|sslProtocols|TLSv1.2|The ssl protocols that needs to be to used to connect to the kafka servers. The allowed values are depending on your Java installation, but unless you have specific demands the default will be sufficient secure.
|sslKeystoreLocation||The location of you ssl keystore. The keystore contains your public/private key pair to identify your Node.
|sslKeystorePassword||The password of the ssl keystore.
|sslKeystoreType|PKCS12|The ssl keystore type.
|sslTruststoreLocation||The location of you ssl truststore. The trust store contains certificates of Kafka machines that this Node is allowed to connect to.
|sslTruststorePassword||The password of the ssl truststore.
|sslTruststoreType|JSK|The ssl truststore type.
|=======================

==== Signaler section in etm.yml
The ''signaler'' section contains all options to configure the signaler.

.Signaler configuration options
[options="header"]
|=======================
|Name|Default value|Description
|enabled|true|Should the signaler be enabled? Set this value to true to let this node send signals to end users/systems.
|=======================

==== Logging section in etm.yml
The ''logging'' section contains all options to configure the loggers and log levels. Log levels can be one of TRACE, DEBUG, INFO, WARNING or ERROR.

.Logging configuration options
[options="header"]
|=======================
|Name|Default value|Description
|rootLogger|INFO|The root logging level. If no specific logger is configured, this value will be used.
|loggers||A map with string key/value pairs. The key is the name of the logger and the value is the log level to be used for that specific logger.
|=======================

